<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Specs on libp2p</title>
    <link>/specs/</link>
    <description>Recent content in Specs on libp2p</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>All rights reserved - 2016</copyright>
    <lastBuildDate>Fri, 01 Jan 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="/specs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>libp2p</title>
      <link>/specs/test/</link>
      <pubDate>Fri, 01 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>/specs/test/</guid>
      <description>

&lt;p&gt;Authors:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/jbenet&#34;&gt;Juan Benet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/diasdavid&#34;&gt;David Dias&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;tl;dr; This document presents &lt;code&gt;libp2p&lt;/code&gt;, a modularized and extensible network stack to overcome the networking challenges faced when doing peer-to-peer applications. &lt;code&gt;libp2p&lt;/code&gt; is used by IPFS as its networking library.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;

&lt;p&gt;This describes the &lt;a href=&#34;https://ipfs.io/&#34;&gt;IPFS&lt;/a&gt; network protocol. The network layer provides point-to-point transports (reliable and unreliable) between any two IPFS nodes in the network.&lt;/p&gt;

&lt;p&gt;This document defines the spec implemented in &lt;code&gt;libp2p&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;status-of-this-spec&#34;&gt;Status of this spec&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://img.shields.io/badge/status-wip-orange.svg?style=flat-square&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;organization-of-this-document&#34;&gt;Organization of this document&lt;/h2&gt;

&lt;p&gt;This RFC is organized by chapters described on the &lt;em&gt;Table of contents&lt;/em&gt; section. Each of the chapters can be found in its own file.&lt;/p&gt;

&lt;h2 id=&#34;table-of-contents&#34;&gt;Table of contents&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;1-introduction/&#34;&gt;1 Introduction&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;1-introduction/#1-1-motivation&#34;&gt;1.1 Motivation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;1-introduction/#12-goals&#34;&gt;1.2 Goals&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;2-state-of-the-art/&#34;&gt;2 An analysis the state of the art in network stacks&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;2-state-of-the-art/#21-the-client-server-model&#34;&gt;2.1 The client-server model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;2-state-of-the-art/#22-categorizing-the-network-stack-protocols-by-solutions&#34;&gt;2.2 Categorizing the network stack protocols by solutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;2-state-of-the-art/#23-current-shortcommings&#34;&gt;2.3 Current shortcommings&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/&#34;&gt;3 Requirements&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/#31-nat-traversal&#34;&gt;3.1 NAT traversal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/#32-relay&#34;&gt;3.2 Relay&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/#33-encryption&#34;&gt;3.3 Encryption&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/#34-transport-agnostic&#34;&gt;3.4 Transport agnostic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/#35-multi-multiplexing&#34;&gt;3.5 Multi-multiplexing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/#36-enable-several-network-topologies&#34;&gt;3.6 Enable several network topologies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3-requirements/#37-resource-discovery&#34;&gt;3.7 Resource discovery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;4-architecture/&#34;&gt;4 Architecture&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;4-architecture/#41-peer-routing&#34;&gt;4.1 Peer Routing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;4-architecture/#42-swarm&#34;&gt;4.2 Swarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;4-architecture/#43-distributed-record-store&#34;&gt;4.3 Distributed Record Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;4-architecture/#44-discovery&#34;&gt;4.4 Discovery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;5-datastructures/&#34;&gt;5 Data structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;6-interfaces/&#34;&gt;6 Interfaces&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;6-interfaces/#61-libp2p&#34;&gt;6.1 libp2p&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;6-interfaces/#62-peer-routing&#34;&gt;6.2 Peer Routing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;6-interfaces/#63-swarm&#34;&gt;6.3 Swarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;6-interfaces/#64-distributed-record-store&#34;&gt;6.4 Distributed Record Store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;6-interfaces/#65-peer-discovery&#34;&gt;6.5 Peer Discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;6-interfaces/#66-libp2p-interface-and-ux&#34;&gt;6.6 libp2p interface and UX&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/&#34;&gt;7 Properties&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#71-communication-model---streams&#34;&gt;7.1 Communication Model - Streams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#72-ports---constrained-entrypoints&#34;&gt;7.2 Ports - Constrained Entrypoints&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#73-transport-protocols&#34;&gt;7.3 Transport Protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#74-non-ip-networks&#34;&gt;7.4 Non-IP Networks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#75-on-the-wire&#34;&gt;7.5 On the wire&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#751-protocol-multiplexing&#34;&gt;7.5.1 Protocol-Multiplexing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#752-multistream---self-describing-protocol-stream&#34;&gt;7.5.2 multistream - self-describing protocol stream&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#753-multistream-selector---self-describing-protocol-stream-selector&#34;&gt;7.5.3 multistream-selector - self-describing protocol stream selector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#754-stream-multiplexing&#34;&gt;7.5.4 Stream Multiplexing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#755-portable-encodings&#34;&gt;7.5.5 Portable Encodings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;7-properties/#756-secure-communications&#34;&gt;7.5.6 Secure Communications&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;8-implementations/&#34;&gt;8 Implementations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;9-references/&#34;&gt;9 References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;contribute&#34;&gt;Contribute&lt;/h2&gt;

&lt;p&gt;Please contribute! &lt;a href=&#34;https://github.com/libp2p/spec/issues&#34;&gt;Dive into the issues&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Please be aware that all interactions related to multiformats are subject to the IPFS &lt;a href=&#34;https://github.com/ipfs/community/blob/master/code-of-conduct.md&#34;&gt;Code of Conduct&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1 Introduction</title>
      <link>/specs/1-introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/1-introduction/</guid>
      <description>

&lt;p&gt;While developing &lt;a href=&#34;https://ipfs.io/&#34;&gt;IPFS, the InterPlanetary FileSystem&lt;/a&gt;, we came to learn about several challenges imposed by having to run a distributed file system on top of heterogeneous devices, with diferent network setups and capabilities. During this process, we had to revisit the whole network stack and elaborate solutions to overcome the obstacles imposed by design decisions of the several layers and protocols, without breaking compatibility or recreating technologies.&lt;/p&gt;

&lt;p&gt;In order to build this library, we focused on tackling problems independently, creating less complex solutions with powerful abstractions that, when composed, can offer an environment for a peer-to-peer application to work sucessfuly.&lt;/p&gt;

&lt;h2 id=&#34;1-1-motivation&#34;&gt;1.1 Motivation&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; is the result of our collective experience of building a distributed system, in that it puts responsibility on developers to decide how they want an app to interoperate with others in the network, and favors configuration and extensibility instead of making assumptions about the network setup.&lt;/p&gt;

&lt;p&gt;In essence, a peer using &lt;code&gt;libp2p&lt;/code&gt; should be able to communicate with another peer using a variety of different transports, including connection relay, and talk over different protocols, negotiated on demand.&lt;/p&gt;

&lt;h2 id=&#34;1-2-goals&#34;&gt;1.2 Goals&lt;/h2&gt;

&lt;p&gt;Our goals for the &lt;code&gt;libp2p&lt;/code&gt; specification and its implementations are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Enable the use of various:

&lt;ul&gt;
&lt;li&gt;transports: TCP, UDP, SCTP, UDT, uTP, QUIC, SSH, etc.&lt;/li&gt;
&lt;li&gt;authenticated transports: TLS, DTLS, CurveCP, SSH&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Make efficient use of sockets (connection reuse)&lt;/li&gt;
&lt;li&gt;Enable communications between peers to be multiplexed over one socket (avoiding handshake overhead)&lt;/li&gt;
&lt;li&gt;Enable multiprotocols and respective versions to be used between peers, using a negotiation process&lt;/li&gt;
&lt;li&gt;Be backwards compatible&lt;/li&gt;
&lt;li&gt;Work in current systems&lt;/li&gt;
&lt;li&gt;Use the full capabilities of current network technologies&lt;/li&gt;
&lt;li&gt;Have NAT traversal&lt;/li&gt;
&lt;li&gt;Enable connections to be relayed&lt;/li&gt;
&lt;li&gt;Enable encrypted channels&lt;/li&gt;
&lt;li&gt;Make efficient use of underlying transports (e.g. native stream muxing, native auth, etc.)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2 An analysis of the state of the art in network stacks</title>
      <link>/specs/2-state-of-the-art/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/2-state-of-the-art/</guid>
      <description>

&lt;p&gt;This section presents to the reader an analysis of the available protocols and architectures for network stacks. The goal is to provide the foundations from which to infer the conclusions and understand why &lt;code&gt;libp2p&lt;/code&gt; has the requirements and architecture that it has.&lt;/p&gt;

&lt;h2 id=&#34;2-1-the-client-server-model&#34;&gt;2.1 The client-server model&lt;/h2&gt;

&lt;p&gt;The client-server model indicates that both parties at the ends of the channel have different roles, that they support different services and/or have different capabilities, or in other words, that they speak different protocols.&lt;/p&gt;

&lt;p&gt;Building client-server applications has been the natural tendency for a number of reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The bandwidth inside a data center is considerably higher than that available for clients to connect to each other.&lt;/li&gt;
&lt;li&gt;Data center resources are considerably cheaper, due to efficient usage and bulk stocking.&lt;/li&gt;
&lt;li&gt;It makes it easier for the developer and system admin to have fine grained control over the application.&lt;/li&gt;
&lt;li&gt;It reduces the number of heteregeneus systems to be handled (although the number is still considerable).&lt;/li&gt;
&lt;li&gt;Systems like NAT make it really hard for client machines to find and talk with each other, forcing a developer to perform very clever hacks to traverse these obstacles.&lt;/li&gt;
&lt;li&gt;Protocols started to be designed with the assumption that a developer will create a client-server application from the start.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We even learned how to hide all the complexity of a distributed system behind gateways on the Internet, using protocols that were designed to perform a point-to-point operation, such as HTTP, making it opaque for the application to see and understand the cascade of service calls made for each request.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; offers a move towards dialer-listener interactions, from the client-server listener, where it is not implicit which of the entities, dialer or listener, has which capabilities or is enabled to perform which actions. Setting up a connection between two applications today is a multilayered problem to solve, and these connections should not have a purpose bias, and should instead support several other protocols to work on top of the established connection. In a client-server model, a server sending data without a prior request from the client is known as a push model, which typically adds more complexity; in a dialer-listener model in comparison, both entities can perform requests independently.&lt;/p&gt;

&lt;h2 id=&#34;2-2-categorizing-the-network-stack-protocols-by-solutions&#34;&gt;2.2 Categorizing the network stack protocols by solutions&lt;/h2&gt;

&lt;p&gt;Before diving into the &lt;code&gt;libp2p&lt;/code&gt; protocols, it is important to understand the large diversity of protocols already in wide use and deployment that help maintain today&amp;rsquo;s simple abstractions. For example, when one thinks about an HTTP connection, one might naively just think that HTTP/TCP/IP are the main protocols involved, but in reality many more protocols participate, depending on the usage, the networks involved, and so on. Protocols like DNS, DHCP, ARP, OSPF, Ethernet, 802.11 (Wi-Fi) and many others get involved. Looking inside ISPs&amp;rsquo; own networks would reveal dozens more.&lt;/p&gt;

&lt;p&gt;Additionally, it&amp;rsquo;s worth noting that the traditional 7-layer OSI model characterization does not fit &lt;code&gt;libp2p&lt;/code&gt;. Instead, we categorize protocols based on their role, i.e. the problem they solve. The upper layers of the OSI model are geared towards point-to-point links between applications, whereas the &lt;code&gt;libp2p&lt;/code&gt; protocols speak more towards various sizes of networks, with various properties, under various different security models. Different &lt;code&gt;libp2p&lt;/code&gt; protocols can have the same role (in the OSI model, this would be &amp;ldquo;address the same layer&amp;rdquo;), meaning that multiple protocols can run simultaneously, all addressing one role (instead of one-protocol-per-layer in traditional OSI stacking). For example, bootstrap lists, mDNS, DHT discovery, and PEX are all forms of the role &amp;ldquo;Peer Discovery&amp;rdquo;; they can coexist and even synergize.&lt;/p&gt;

&lt;h3 id=&#34;2-2-1-establishing-the-physical-link&#34;&gt;2.2.1 Establishing the physical link&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Ethernet&lt;/li&gt;
&lt;li&gt;Wi-Fi&lt;/li&gt;
&lt;li&gt;Bluetooth&lt;/li&gt;
&lt;li&gt;USB&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-2-addressing-a-machine-or-process&#34;&gt;2.2.2 Addressing a machine or process&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;IPv4&lt;/li&gt;
&lt;li&gt;IPv6&lt;/li&gt;
&lt;li&gt;Hidden addressing, like SDP&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-3-discovering-other-peers-or-services&#34;&gt;2.2.3 Discovering other peers or services&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ARP&lt;/li&gt;
&lt;li&gt;DHCP&lt;/li&gt;
&lt;li&gt;DNS&lt;/li&gt;
&lt;li&gt;Onion&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-4-routing-messages-through-the-network&#34;&gt;2.2.4 Routing messages through the network&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;RIP(1, 2)&lt;/li&gt;
&lt;li&gt;OSPF&lt;/li&gt;
&lt;li&gt;PPP&lt;/li&gt;
&lt;li&gt;Tor&lt;/li&gt;
&lt;li&gt;I2P&lt;/li&gt;
&lt;li&gt;cjdns&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-5-transport&#34;&gt;2.2.5 Transport&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;TCP&lt;/li&gt;
&lt;li&gt;UDP&lt;/li&gt;
&lt;li&gt;UDT&lt;/li&gt;
&lt;li&gt;QUIC&lt;/li&gt;
&lt;li&gt;WebRTC data channel&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-6-agreed-semantics-for-applications-to-talk-to-each-other&#34;&gt;2.2.6 Agreed semantics for applications to talk to each other&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;RMI&lt;/li&gt;
&lt;li&gt;Remoting&lt;/li&gt;
&lt;li&gt;RPC&lt;/li&gt;
&lt;li&gt;HTTP&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-3-current-shortcommings&#34;&gt;2.3 Current shortcommings&lt;/h2&gt;

&lt;p&gt;Although we currently have a panoply of protocols available for our services to communicate, the abundance and variety of solutions creates its own problems. It is currently difficult for an application to be able to support and be available through several transports (e.g. the lack of TCP/UDP stack in browser applications).&lt;/p&gt;

&lt;p&gt;There is also no &amp;lsquo;presence linking&amp;rsquo;, meaning that there isn&amp;rsquo;t a notion for a peer to announce itself in several transports, so that other peers can guarantee that it is always the same peer.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3 Requirements and considerations</title>
      <link>/specs/3-requirements/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/3-requirements/</guid>
      <description>

&lt;h2 id=&#34;3-1-nat-traversal&#34;&gt;3.1 NAT traversal&lt;/h2&gt;

&lt;p&gt;Network Address Translation is ubiquitous in the Internet. Not only are most consumer devices behind many layers of NAT, but most data center nodes are often behind NAT for security or virtualization reasons. As we move into containerized deployments, this is getting worse. IPFS implementations SHOULD provide a way to traverse NATs, otherwise it is likely that operation will be affected. Even nodes meant to run with real IP addresses must implement NAT traversal techniques, as they may need to establish connections to peers behind NAT.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; accomplishes full NAT traversal using an ICE-like protocol. It is not exactly ICE, as IPFS networks provide the possibility of relaying communications over the IPFS protocol itself, for coordinating hole-punching or even relaying communication.&lt;/p&gt;

&lt;p&gt;It is recommended that implementations use one of the many NAT traversal libraries available, such as &lt;code&gt;libnice&lt;/code&gt;, &lt;code&gt;libwebrtc&lt;/code&gt;, or &lt;code&gt;natty&lt;/code&gt;. However, NAT traversal must be interoperable.&lt;/p&gt;

&lt;h2 id=&#34;3-2-relay&#34;&gt;3.2 Relay&lt;/h2&gt;

&lt;p&gt;Unfortunately, due to symmetric NATs, container and VM NATs, and other impossible-to-bypass NATs, &lt;code&gt;libp2p&lt;/code&gt; MUST fallback to relaying communication to establish a full connectivity graph. To be complete, implementations MUST support relay, though it SHOULD be optional and able to be turned off by end users.&lt;/p&gt;

&lt;h2 id=&#34;3-3-encryption&#34;&gt;3.3 Encryption&lt;/h2&gt;

&lt;p&gt;Communications on &lt;code&gt;libp2p&lt;/code&gt; may be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;encrypted&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;signed&lt;/strong&gt; (not encrypted)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clear&lt;/strong&gt; (not encrypted, not signed)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We take both security and performance seriously. We recognize that encryption is not viable for some in-datacenter high performance use cases.&lt;/p&gt;

&lt;p&gt;We recommend that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;implementations encrypt all communications by default&lt;/li&gt;
&lt;li&gt;implementations are audited&lt;/li&gt;
&lt;li&gt;unless absolutely necessary, users normally operate with encrypted communications only.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; uses cyphersuites like TLS.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; We do not use TLS directly, because we do not want the CA system baggage. Most TLS implementations are very big. Since the &lt;code&gt;libp2p&lt;/code&gt; model begins with keys, &lt;code&gt;libp2p&lt;/code&gt; only needs to apply ciphers. This is a minimal portion of the whole TLS standard.&lt;/p&gt;

&lt;h2 id=&#34;3-4-transport-agnostic&#34;&gt;3.4 Transport agnostic&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; is transport agnostic, so it can run over any transport protocol. It does not even depend on IP; it may run on top of NDN, XIA, and other new Internet architectures.&lt;/p&gt;

&lt;p&gt;In order to reason about possible transports, &lt;code&gt;libp2p&lt;/code&gt; uses &lt;a href=&#34;https://github.com/jbenet/multiaddr&#34;&gt;multiaddr&lt;/a&gt;, a self-describing addressing format. This makes it possible for &lt;code&gt;libp2p&lt;/code&gt; to treat addresses opaquely everywhere in the system, and have support for various transport protocols in the network layer. The actual format of addresses in &lt;code&gt;libp2p&lt;/code&gt; is &lt;code&gt;ipfs-addr&lt;/code&gt;, a multiaddr that ends with an IPFS node id. For example, these are all valid &lt;code&gt;ipfs-addrs&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# IPFS over TCP over IPv6 (typical TCP)
/ip6/fe80::8823:6dff:fee7:f172/tcp/4001/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over uTP over UDP over IPv4 (UDP-shimmed transport)
/ip4/162.246.145.218/udp/4001/utp/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over IPv6 (unreliable)
/ip6/fe80::8823:6dff:fee7:f172/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over TCP over IPv4 over TCP over IPv4 (proxy)
/ip4/162.246.145.218/tcp/7650/ip4/192.168.0.1/tcp/4001/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu

# IPFS over Ethernet (no IP)
/ether/ac:fd:ec:0b:7c:fe/ipfs/QmYJyUMAcXEw1b5bFfbBbzYu5wyyjLMRHXGUkCXpag74Fu
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; At this time, no unreliable implementations exist. The protocol&amp;rsquo;s interface for defining and using unreliable transport has not been defined.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TODO:&lt;/strong&gt; Define how unreliable transport would work. Base it on WebRTC.&lt;/p&gt;

&lt;h2 id=&#34;3-5-multi-multiplexing&#34;&gt;3.5 Multi-multiplexing&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;libp2p&lt;/code&gt; protocol is a collection of multiple protocols. In order to conserve resources, and to make connectivity easier, &lt;code&gt;libp2p&lt;/code&gt; can perform all its operations through a single port, such as a TCP or UDP port, depending on the transports used. &lt;code&gt;libp2p&lt;/code&gt; can multiplex its many protocols through point-to-point connections. This multiplexing is for both reliable streams and unreliable datagrams.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; is pragmatic. It seeks to be usable in as many settings as possible, to be modular and flexible to fit various use cases, and to force as few choices as possible. Thus the &lt;code&gt;libp2p&lt;/code&gt; network layer provides what we&amp;rsquo;re loosely referring to as &amp;ldquo;multi-multiplexing&amp;rdquo;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;can multiplex multiple listen network interfaces&lt;/li&gt;
&lt;li&gt;can multiplex multiple transport protocols&lt;/li&gt;
&lt;li&gt;can multiplex multiple connections per peer&lt;/li&gt;
&lt;li&gt;can multiplex multiple client protocols&lt;/li&gt;
&lt;li&gt;can multiplex multiple streams per protocol, per connection (SPDY, HTTP2, QUIC, SSH)&lt;/li&gt;
&lt;li&gt;has flow control (backpressure, fairness)&lt;/li&gt;
&lt;li&gt;encrypts each connection with a different ephemeral key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To give an example, imagine a single IPFS node that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;listens on a particular TCP/IP address&lt;/li&gt;
&lt;li&gt;listens on a different TCP/IP address&lt;/li&gt;
&lt;li&gt;listens on a SCTP/UDP/IP address&lt;/li&gt;
&lt;li&gt;listens on a UDT/UDP/IP address&lt;/li&gt;
&lt;li&gt;has multiple connections to another node X&lt;/li&gt;
&lt;li&gt;has multiple connections to another node Y&lt;/li&gt;
&lt;li&gt;has multiple streams open per connection&lt;/li&gt;
&lt;li&gt;multiplexes streams over HTTP2 to node X&lt;/li&gt;
&lt;li&gt;multiplexes streams over SSH to node Y&lt;/li&gt;
&lt;li&gt;one protocol mounted on top of &lt;code&gt;libp2p&lt;/code&gt; uses one stream per peer&lt;/li&gt;
&lt;li&gt;one protocol mounted on top of &lt;code&gt;libp2p&lt;/code&gt; uses multiple streams per peer&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Not providing this level of flexbility makes it impossible to use &lt;code&gt;libp2p&lt;/code&gt; in various platforms, use cases, or network setups. It is not important that all implementations support all choices; what is critical is that the spec is flexible enough to allow implementations to use precisely what they need. This ensures that complex user or application constraints do not rule out &lt;code&gt;libp2p&lt;/code&gt; as an option.&lt;/p&gt;

&lt;h2 id=&#34;3-6-enable-several-network-topologies&#34;&gt;3.6 Enable several network topologies&lt;/h2&gt;

&lt;p&gt;Different systems have different requirements and with that comes different topologies. In the P2P literature we can find these topologies being enumerated as: unstructured, structured, hybrid and centralized.&lt;/p&gt;

&lt;p&gt;Centralized topologies are the most common to find in Web Applications infrastructures, it requires for a given service or services to be present at all times in a known static location, so that other services can access them. Unstructured networks represent a type of P2P networks where the network topology is completely random, or at least non deterministic, while structured networks have a implicit way of organizing themselves. Hybrid networks are a mix of the last two.&lt;/p&gt;

&lt;p&gt;With this in consideration, &lt;code&gt;libp2p&lt;/code&gt; must be ready to perform different routing mechanisms and peer discovery, in order to build the routing tables that will enable services to propagate messages or to find each other.&lt;/p&gt;

&lt;h2 id=&#34;3-7-resource-discovery&#34;&gt;3.7 Resource discovery&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; also solves the problem with discoverability of resources inside of a network through &lt;em&gt;records&lt;/em&gt;.  A record is a unit of data that can be digitally signed, timestamped and/or used with other methods to give it an ephemeral validity. These records hold pieces of information such as location or availability of resources present in the network. These resources can be data, storage, CPU cycles and other types of services.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; must not put a constraint on the location of resources, but instead offer ways to find them easily in the network or use a side channel.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4 Architecture</title>
      <link>/specs/4-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/4-architecture/</guid>
      <description>

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; was designed around the Unix Philosophy of creating small components that are easy to understand and test. These components should also be able to be swapped in order to accomodate different technologies or scenarios and also make it feasible to upgrade them over time.&lt;/p&gt;

&lt;p&gt;Although different peers can support different protocols depending on their capabilities, any peer can act as a dialer and/or a listener for connections from other peers, connections that once established can be reused from both ends, removing the distinction between clients and servers.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;libp2p&lt;/code&gt; interface acts as a thin veneer over a multitude of subsystems that are required in order for peers to be able to communicate. These subsystems are allowed to be built on top of other subsystems as long as they respect the standardized interface. The main areas where these subsystems fit are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Peer Routing - Mechanism to decide which peers to use for routing particular messages. This routing can be done recursively, iteratively or even in a broadcast/multicast mode.&lt;/li&gt;
&lt;li&gt;Swarm - Handles everything that touches the &amp;lsquo;opening a stream&amp;rsquo; part of &lt;code&gt;libp2p&lt;/code&gt;, from protocol muxing, stream muxing, NAT traversal and connection relaying, while being multi-transport.&lt;/li&gt;
&lt;li&gt;Distributed Record Store - A system to store and distribute records. Records are small entries used by other systems for signaling, establishing links, announcing peers or content, and so on. They have a similar role to DNS in the broader Internet.&lt;/li&gt;
&lt;li&gt;Discovery - Finding or identifying other peers in the network.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of these subsystems exposes a well known interface (see &lt;a href=&#34;6-interfaces.md&#34;&gt;chapter 6&lt;/a&gt; for Interfaces) and may use each other in order to fulfil their goal. A global overview of the system is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌─────────────────────────────────────────────────────────────────────────────────┐
│                                  libp2p                                         │
└─────────────────────────────────────────────────────────────────────────────────┘
┌─────────────────┐┌─────────────────┐┌──────────────────────────┐┌───────────────┐
│   Peer Routing  ││      Swarm      ││ Distributed Record Store ││  Discovery    │
└─────────────────┘└─────────────────┘└──────────────────────────┘└───────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-1-peer-routing&#34;&gt;4.1 Peer Routing&lt;/h2&gt;

&lt;p&gt;A Peer Routing subsystem exposes an interface to identify which peers a message should be routed to in the DHT. It receives a key and must return one or more &lt;code&gt;PeerInfo&lt;/code&gt; objects.&lt;/p&gt;

&lt;p&gt;We present two examples of possible Peer Routing subsystems, the first based on a the Kademlia DHT and the second based on mDNS. Nevertheless, other Peer Routing mechanisms can be implemented, as long as they fulfil the same expectation and interface.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;┌──────────────────────────────────────────────────────────────┐
│       Peer Routing                                           │
│                                                              │
│┌──────────────┐┌────────────────┐┌──────────────────────────┐│
││ kad-routing  ││ mDNS-routing   ││ other-routing-mechanisms ││
││              ││                ││                          ││
││              ││                ││                          ││
│└──────────────┘└────────────────┘└──────────────────────────┘│
└──────────────────────────────────────────────────────────────┘
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;4-1-1-kad-routing&#34;&gt;4.1.1 kad-routing&lt;/h3&gt;

&lt;p&gt;kad-routing implements the Kademlia Routing table, where each peer holds a set of k-buckets, each of them containing several &lt;code&gt;PeerInfo&lt;/code&gt; objects from other peers in the network.&lt;/p&gt;

&lt;h3 id=&#34;4-1-2-mdns-routing&#34;&gt;4.1.2 mDNS-routing&lt;/h3&gt;

&lt;p&gt;mDNS-routing uses mDNS probes to identify if local area network peers have a given key or they are simply present.&lt;/p&gt;

&lt;h2 id=&#34;4-2-swarm&#34;&gt;4.2 Swarm&lt;/h2&gt;

&lt;h3 id=&#34;4-2-1-stream-muxer&#34;&gt;4.2.1 Stream Muxer&lt;/h3&gt;

&lt;p&gt;The stream muxer must implement the interface offered by &lt;a href=&#34;https://github.com/diasdavid/interface-stream-muxer&#34;&gt;interface-stream-muxer&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;4-2-2-protocol-muxer&#34;&gt;4.2.2 Protocol Muxer&lt;/h3&gt;

&lt;p&gt;Protocol muxing is handled on the application level instead of the conventional way at the port level (where different services/protocols listen at different ports). This enables us to support several protocols to be muxed in the same socket, saving the cost of doing NAT traversal for more than one port.&lt;/p&gt;

&lt;p&gt;Protocol multiplexing is done through &lt;a href=&#34;https://github.com/jbenet/multistream&#34;&gt;&lt;code&gt;multistream&lt;/code&gt;&lt;/a&gt;, a protocol to negotiate different types of streams (protocols) using &lt;a href=&#34;https://github.com/jbenet/multicodec&#34;&gt;&lt;code&gt;multicodec&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;4-2-3-transport&#34;&gt;4.2.3 Transport&lt;/h3&gt;

&lt;h3 id=&#34;4-2-4-crypto&#34;&gt;4.2.4 Crypto&lt;/h3&gt;

&lt;h3 id=&#34;4-2-5-identify&#34;&gt;4.2.5 Identify&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Identify&lt;/strong&gt; is one of the protocols mounted on top of Swarm, our Connection handler. However, it follows and respects the same pattern as any other protocol when it comes to mounting it on top of Swarm. Identify enables us to trade &lt;code&gt;listenAddrs&lt;/code&gt; and &lt;code&gt;observedAddrs&lt;/code&gt; between peers, which is crucial for the working of IPFS. Since every socket open implements &lt;code&gt;REUSEPORT&lt;/code&gt;, an &lt;code&gt;observedAddr&lt;/code&gt; by another peer can enable a third peer to connect to us, since the port will be already open and redirect to us on a NAT.&lt;/p&gt;

&lt;h3 id=&#34;4-2-6-relay&#34;&gt;4.2.6 Relay&lt;/h3&gt;

&lt;h2 id=&#34;4-3-distributed-record-store&#34;&gt;4.3 Distributed Record Store&lt;/h2&gt;

&lt;h3 id=&#34;4-3-1-record&#34;&gt;4.3.1 Record&lt;/h3&gt;

&lt;p&gt;Follows &lt;a href=&#34;../iprs-interplanetary-record-system&#34;&gt;IPRS&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;4-3-2-abstract-record-store&#34;&gt;4.3.2 abstract-record-store&lt;/h3&gt;

&lt;h3 id=&#34;4-3-3-kad-record-store&#34;&gt;4.3.3 kad-record-store&lt;/h3&gt;

&lt;h3 id=&#34;4-3-4-mdns-record-store&#34;&gt;4.3.4 mDNS-record-store&lt;/h3&gt;

&lt;h3 id=&#34;4-3-5-s3-record-store&#34;&gt;4.3.5 s3-record-store&lt;/h3&gt;

&lt;h2 id=&#34;4-4-discovery&#34;&gt;4.4 Discovery&lt;/h2&gt;

&lt;h3 id=&#34;4-4-1-mdns-discovery&#34;&gt;4.4.1 mDNS-discovery&lt;/h3&gt;

&lt;p&gt;mDNS-discovery is a Discovery Protocol that uses &lt;a href=&#34;https://en.wikipedia.org/wiki/Multicast_DNS&#34;&gt;mDNS&lt;/a&gt; over local area networks. It emits mDNS beacons to find if there are more peers available. Local area network peers are very useful to peer-to-peer protocols, because of their low latency links.&lt;/p&gt;

&lt;p&gt;mDNS-discovery is a standalone protocol and does not depend on any other &lt;code&gt;libp2p&lt;/code&gt; protocol. mDNS-discovery can yield peers available in the local area network, without relying on other infrastructure. This is particularly useful in intranets, networks disconnected from the Internet backbone, and networks which temporarily lose links.&lt;/p&gt;

&lt;p&gt;mDNS-discovery can be configured per-service (i.e. discover only peers participating in a specific protocol, like IPFS), and with private networks (discover peers belonging to a private network).&lt;/p&gt;

&lt;p&gt;We are exploring ways to make mDNS-discovery beacons encrypted (so that other nodes in the local network cannot discern what service is being used), though the nature of mDNS will always reveal local IP addresses.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Privacy note:&lt;/strong&gt; mDNS advertises in local area networks, which reveals IP addresses to listeners in the same local network. It is not recommended to use this with privacy-sensitive applications or oblivious routing protocols.&lt;/p&gt;

&lt;h4 id=&#34;4-4-2-random-walk&#34;&gt;4.4.2 random-walk&lt;/h4&gt;

&lt;p&gt;Random-Walk is a Discovery Protocol for DHTs (and other protocols with routing tables). It makes random DHT queries in order to learn about a large number of peers quickly. This causes the DHT (or other protocols) to converge much faster, at the expense of a small load at the very beginning.&lt;/p&gt;

&lt;h4 id=&#34;4-4-3-bootstrap-list&#34;&gt;4.4.3 bootstrap-list&lt;/h4&gt;

&lt;p&gt;Bootstrap-List is a Discovery Protocol that uses local storage to cache the addresses of highly stable (and somewhat trusted) peers available in the network. This allows protocols to &amp;ldquo;find the rest of the network&amp;rdquo;. This is essentially the same way that DNS bootstraps itself (though note that changing the DNS bootstrap list &amp;ndash; the &amp;ldquo;dot domain&amp;rdquo; addresses &amp;ndash; is not easy to do, by design).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The list should be stored in long-term local storage, whatever that means to the local node (e.g. to disk).&lt;/li&gt;
&lt;li&gt;Protocols can ship a default list hardcoded or along with the standard code distribution (like DNS).&lt;/li&gt;
&lt;li&gt;In most cases (and certainly in the case of IPFS) the bootstrap list should be user configurable, as users may wish to establish separate networks, or place their reliance and trust in specific nodes.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>5 Data Structures</title>
      <link>/specs/5-datastructures/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/5-datastructures/</guid>
      <description>&lt;p&gt;=================&lt;/p&gt;

&lt;p&gt;The network protocol deals with these data structures:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a &lt;code&gt;PrivateKey&lt;/code&gt;, the private key of a node.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;PublicKey&lt;/code&gt;, the public key of a node.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;PeerId&lt;/code&gt;, a hash of a node&amp;rsquo;s public key.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;PeerInfo&lt;/code&gt;, an object containing a node&amp;rsquo;s &lt;code&gt;PeerId&lt;/code&gt; and its known multiaddrs.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;Transport&lt;/code&gt;, a transport used to establish connections to other peers. See &lt;a href=&#34;https://github.com/diasdavid/interface-transport&#34;&gt;https://github.com/diasdavid/interface-transport&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;Connection&lt;/code&gt;, a point-to-point link between two nodes. Must implement &lt;a href=&#34;https://github.com/diasdavid/interface-connection&#34;&gt;https://github.com/diasdavid/interface-connection&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;Muxed-Stream&lt;/code&gt;, a duplex message channel.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;Stream-Muxer&lt;/code&gt;, a stream multiplexer. Must implement &lt;a href=&#34;https://github.com/diasdavid/interface-stream-muxer&#34;&gt;https://github.com/diasdavid/interface-stream-muxer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;Record&lt;/code&gt;, IPLD (IPFS Linked Data) described object that implements &lt;a href=&#34;../records&#34;&gt;IPRS&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;multiaddr&lt;/code&gt;, a self describable network address. See &lt;a href=&#34;https://github.com/jbenet/multiaddr&#34;&gt;https://github.com/jbenet/multiaddr&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;multicodec&lt;/code&gt;, a self describable encoding type. See &lt;a href=&#34;https://github.com/jbenet/multicodec&#34;&gt;https://github.com/jbenet/multicodec&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;multihash&lt;/code&gt;, a self describable hash. See &lt;a href=&#34;https://github.com/jbenet/multihash&#34;&gt;https://github.com/jbenet/multihash&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>6 Interfaces</title>
      <link>/specs/6-interfaces/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/6-interfaces/</guid>
      <description>

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; is a collection of several protocols working together to offer a common solid interface that can talk with any other network addressable process. This is made possible by shimming currently existing protocols and implementations into a set of explicit interfaces: Peer Routing, Discovery, Stream Muxing, Transports, Connections and so on.&lt;/p&gt;

&lt;h2 id=&#34;6-1-libp2p&#34;&gt;6.1 libp2p&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt;, the top module that provides an interface to all the other modules that make a &lt;code&gt;libp2p&lt;/code&gt; instance, must offer an interface for dialing to a peer and plugging in all of the modules (e.g. which transports) we want to support. We present the &lt;code&gt;libp2p&lt;/code&gt; interface and UX in &lt;a href=&#34;#66-libp2p-interface-and-ux&#34;&gt;section 6.6&lt;/a&gt;, after presenting every other module interface.&lt;/p&gt;

&lt;h2 id=&#34;6-2-peer-routing&#34;&gt;6.2 Peer Routing&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/diasdavid/interface-peer-routing/master/img/badge.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A Peer Routing module offers a way for a &lt;code&gt;libp2p&lt;/code&gt; &lt;code&gt;Node&lt;/code&gt; to find the &lt;code&gt;PeerInfo&lt;/code&gt; of another &lt;code&gt;Node&lt;/code&gt;, so that it can dial that node. In its most pure form, a Peer Routing module should have an interface that takes a &amp;lsquo;key&amp;rsquo;, and returns a set of &lt;code&gt;PeerInfo&lt;/code&gt;s.
See &lt;a href=&#34;https://github.com/diasdavid/interface-peer-routing&#34;&gt;https://github.com/diasdavid/interface-peer-routing&lt;/a&gt; for the interface and tests.&lt;/p&gt;

&lt;h2 id=&#34;6-3-swarm&#34;&gt;6.3 Swarm&lt;/h2&gt;

&lt;p&gt;Current interface available and updated at:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/diasdavid/js-libp2p-swarm#usage&#34;&gt;https://github.com/diasdavid/js-libp2p-swarm#usage&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-3-1-transport&#34;&gt;6.3.1 Transport&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/diasdavid/interface-transport/master/img/badge.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-transport&#34;&gt;https://github.com/diasdavid/interface-transport&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-3-2-connection&#34;&gt;6.3.2 Connection&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/diasdavid/interface-connection/master/img/badge.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-connection&#34;&gt;https://github.com/diasdavid/interface-connection&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-3-3-stream-muxing&#34;&gt;6.3.3 Stream Muxing&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://github.com/diasdavid/interface-stream-muxer/raw/master/img/badge.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-stream-muxer&#34;&gt;https://github.com/diasdavid/interface-stream-muxer&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-4-distributed-record-store&#34;&gt;6.4 Distributed Record Store&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/diasdavid/interface-record-store/master/img/badge.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-record-store&#34;&gt;https://github.com/diasdavid/interface-record-store&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-5-peer-discovery&#34;&gt;6.5 Peer Discovery&lt;/h2&gt;

&lt;p&gt;A Peer Discovery module interface should return &lt;code&gt;PeerInfo&lt;/code&gt; objects, as it finds new peers to be considered by our Peer Routing modules.&lt;/p&gt;

&lt;h2 id=&#34;6-6-libp2p-interface-and-ux&#34;&gt;6.6 libp2p interface and UX&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;libp2p&lt;/code&gt; implementations should enable it to be instantiated programatically, or to use a previous compiled library with some of the protocol decisions already made, so that the user can reuse or expand.&lt;/p&gt;

&lt;h3 id=&#34;constructing-a-libp2p-instance-programatically&#34;&gt;Constructing a libp2p instance programatically&lt;/h3&gt;

&lt;p&gt;Example made with JavaScript, should be mapped to other languages:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var Libp2p = require(&#39;libp2p&#39;)

var node = new Libp2p()

// add a swarm instance
node.addSwarm(swarmInstance)

// add one or more Peer Routing mechanisms
node.addPeerRouting(peerRoutingInstance)

// add a Distributed Record Store
node.addDistributedRecordStore(distributedRecordStoreInstance)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Configuring &lt;code&gt;libp2p&lt;/code&gt; is quite straightforward since most of the configuration comes from instantiating the several modules, one at a time.&lt;/p&gt;

&lt;h3 id=&#34;dialing-and-listening-for-connections-to-from-a-peer&#34;&gt;Dialing and Listening for connections to/from a peer&lt;/h3&gt;

&lt;p&gt;Ideally, &lt;code&gt;libp2p&lt;/code&gt; uses its own mechanisms (PeerRouting and Record Store) to find a way to dial to a given peer:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;node.dial(PeerInfo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To receive an incoming connection, specify one or more protocols to handle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;node.handleProtocol(&#39;&amp;lt;multicodec&amp;gt;&#39;, function (duplexStream) {

})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;finding-a-peer&#34;&gt;Finding a peer&lt;/h3&gt;

&lt;p&gt;Finding a peer is done through Peer Routing, so the interface is the same.&lt;/p&gt;

&lt;h3 id=&#34;storing-and-retrieving-records&#34;&gt;Storing and Retrieving Records&lt;/h3&gt;

&lt;p&gt;Like Finding a peer, Storing and Retrieving records is done through Record Store, so the interface is the same.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7 Properties</title>
      <link>/specs/7-properties/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/7-properties/</guid>
      <description>

&lt;h2 id=&#34;7-1-communication-model-streams&#34;&gt;7.1 Communication Model - Streams&lt;/h2&gt;

&lt;p&gt;The Network layer handles all the problems of connecting to a peer, and exposes
simple bidirectional streams. Users can both open a new stream
(&lt;code&gt;NewStream&lt;/code&gt;) and register a stream handler (&lt;code&gt;SetStreamHandler&lt;/code&gt;). The user
is then free to implement whatever wire messaging protocol she desires. This
makes it easy to build peer-to-peer protocols, as the complexities of
connectivity, multi-transport support, flow control, and so on, are handled.&lt;/p&gt;

&lt;p&gt;To help capture the model, consider that:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NewStream&lt;/code&gt; is similar to making a Request in an HTTP client.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SetStreamHandler&lt;/code&gt; is similar to registering a URL handler in an HTTP server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So a protocol, such as a DHT, could:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;node := p2p.NewNode(peerid)

// register a handler, here it is simply echoing everything.
node.SetStreamHandler(&amp;quot;/helloworld&amp;quot;, func (s Stream) {
  io.Copy(s, s)
})

// make a request.
buf1 := []byte(&amp;quot;Hello World!&amp;quot;)
buf2 := make([]byte, len(buf1))

stream, _ := node.NewStream(&amp;quot;/helloworld&amp;quot;, peerid) // open a new stream
stream.Write(buf1)  // write to the remote
stream.Read(buf2)   // read what was sent back
fmt.Println(buf2)   // print what was sent back
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-2-ports-constrained-entrypoints&#34;&gt;7.2 Ports - Constrained Entrypoints&lt;/h2&gt;

&lt;p&gt;In the Internet of 2015, we have a processing model where a program may be
running without the ability to open multiple &amp;ndash; or even single &amp;ndash; network
ports. Most hosts are behind NAT, whether of the household ISP variety or the new
containerized data-center type. And some programs may even be running in
browsers, with no ability to open sockets directly (sort of). This presents
challenges to completely peer-to-peer networks that aspire to connect &lt;em&gt;any&lt;/em&gt;
hosts together &amp;ndash; whether they&amp;rsquo;re running on a page in the browser, or in
a container within a container.&lt;/p&gt;

&lt;p&gt;IPFS only needs a single channel of communication with the rest of the
network. This may be a single TCP or UDP port, or a single connection
through WebSockets or WebRTC. In a sense, the role of the TCP/UDP network
stack &amp;ndash; i.e. multiplexing applications and connections &amp;ndash; may now be forced
to happen at the application level.&lt;/p&gt;

&lt;h2 id=&#34;7-3-transport-protocols&#34;&gt;7.3 Transport Protocols&lt;/h2&gt;

&lt;p&gt;IPFS is transport-agnostic. It can run on any transport protocol. The
&lt;code&gt;ipfs-addr&lt;/code&gt; format (which is an IPFS-specific
&lt;a href=&#34;https://github.com/jbenet/multiaddr&#34;&gt;multiaddr&lt;/a&gt;) describes the transport.
For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# ipv4 + tcp
/ip4/10.1.10.10/tcp/29087/ipfs/QmVcSqVEsvm5RR9mBLjwpb2XjFVn5bPdPL69mL8PH45pPC

# ipv6 + tcp
/ip6/2601:9:4f82:5fff:aefd:ecff:fe0b:7cfe/tcp/1031/ipfs/QmRzjtZsTqL1bMdoJDwsC6ZnDX1PW1vTiav1xewHYAPJNT

# ipv4 + udp + udt
/ip4/104.131.131.82/udp/4001/udt/ipfs/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ

# ipv4 + udp + utp
/ip4/104.131.67.168/udp/1038/utp/ipfs/QmU184wLPg7afQjBjwUUFkeJ98Fp81GhHGurWvMqwvWEQN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;IPFS delegates the transport dialing to a multiaddr-based network package, such
as &lt;a href=&#34;https://github.com/jbenet/go-multiaddr-net&#34;&gt;go-multiaddr-net&lt;/a&gt;. It is
advisable to build modules like this in other languages, and scope the
implementation of other transport protocols.&lt;/p&gt;

&lt;p&gt;Some of the transport protocols we will be using:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;UTP&lt;/li&gt;
&lt;li&gt;UDT&lt;/li&gt;
&lt;li&gt;SCTP&lt;/li&gt;
&lt;li&gt;WebRTC (SCTP, etc)&lt;/li&gt;
&lt;li&gt;WebSockets&lt;/li&gt;
&lt;li&gt;TCP Remy&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-4-non-ip-networks&#34;&gt;7.4 Non-IP Networks&lt;/h2&gt;

&lt;p&gt;Efforts like &lt;a href=&#34;http://named-data.net&#34;&gt;NDN&lt;/a&gt; and
&lt;a href=&#34;http://www.cs.cmu.edu/~xia/&#34;&gt;XIA&lt;/a&gt; are new architectures for the Internet,
which are closer to the model IPFS uses than what IP provides today. IPFS
will be able to operate on top of these architectures trivially, as there
are no assumptions made about the network stack in the protocol. Implementations
will likely need to change, but changing implementations is vastly easier than
changing protocols.&lt;/p&gt;

&lt;h2 id=&#34;7-5-on-the-wire&#34;&gt;7.5 On the wire&lt;/h2&gt;

&lt;p&gt;We have the &lt;strong&gt;hard constraint&lt;/strong&gt; of making IPFS work across &lt;em&gt;any&lt;/em&gt; duplex stream (an outgoing and an incoming stream pair, any arbitrary connection) and work on &lt;em&gt;any&lt;/em&gt; platform.&lt;/p&gt;

&lt;p&gt;To make this work, IPFS has to solve a few problems:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#751-protocol-multiplexing&#34;&gt;Protocol Multiplexing&lt;/a&gt; - running multiple protocols over the same stream

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#752-multistream-self-describing-protocol-stream&#34;&gt;multistream&lt;/a&gt; - self-describing protocol streams&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#753-multistream-selector-self-describing-protocol-stream-selector&#34;&gt;multistream-select&lt;/a&gt; - a self-describing protocol selector&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#754-stream-multiplexing&#34;&gt;Stream Multiplexing&lt;/a&gt; - running many independent streams over the same wire&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#755-portable-encodings&#34;&gt;Portable Encodings&lt;/a&gt; - using portable serialization formats&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#756-secure-communication&#34;&gt;Secure Communications&lt;/a&gt; - using ciphersuites to establish security and privacy (like TLS)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-5-1-protocol-multiplexing&#34;&gt;7.5.1 Protocol-Multiplexing&lt;/h3&gt;

&lt;p&gt;Protocol Multiplexing means running multiple different protocols over the same stream. This could happen sequentially (one after the other), or concurrently (at the same time, with their messages interleaved). We achieve protocol multiplexing using three pieces:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#752-multistream-self-describing-protocol-stream&#34;&gt;multistream&lt;/a&gt; - self-describing protocol streams&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#753-multistream-selector-self-describing-protocol-stream-selector&#34;&gt;multistream-select&lt;/a&gt; - a self-describing protocol selector&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#754-stream-multiplexing&#34;&gt;Stream Multiplexing&lt;/a&gt; - running many independent streams over the same wire&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-5-2-multistream-self-describing-protocol-stream&#34;&gt;7.5.2 multistream - self-describing protocol stream&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jbenet/multistream&#34;&gt;multistream&lt;/a&gt; is a self-describing protocol stream format. It is extremely simple. Its goal is to define a way to add headers to protocols that describe the protocol itself. It is sort of like adding versions to a protocol, but extremely explicit.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ipfs/QmVXZiejj3sXEmxuQxF2RjmFbEiE9w7T82xDn3uYNuhbFb/ipfs-dht/0.2.3
&amp;lt;dht-message&amp;gt;
&amp;lt;dht-message&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-5-3-multistream-selector-self-describing-protocol-stream-selector&#34;&gt;7.5.3 multistream-selector - self-describing protocol stream selector&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/jbenet/multistream/tree/master/multistream&#34;&gt;multistream-select&lt;/a&gt; is a simple &lt;a href=&#34;https://github.com/jbenet/multistream&#34;&gt;multistream&lt;/a&gt; protocol that allows listing and selecting other protocols. This means that Protomux has a list of registered protocols, listens for one, and then &lt;em&gt;nests&lt;/em&gt; (or upgrades) the connection to speak the registered protocol. This takes direct advantage of multistream: it enables interleaving multiple protocols, as well as inspecting what protocols might be spoken by the remote endpoint.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ipfs/QmdRKVhvzyATs3L6dosSb6w8hKuqfZK2SyPVqcYJ5VLYa2/multistream-select/0.3.0
/ipfs/QmVXZiejj3sXEmxuQxF2RjmFbEiE9w7T82xDn3uYNuhbFb/ipfs-dht/0.2.3
&amp;lt;dht-message&amp;gt;
&amp;lt;dht-message&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-5-4-stream-multiplexing&#34;&gt;7.5.4 Stream Multiplexing&lt;/h3&gt;

&lt;p&gt;Stream Multiplexing is the process of multiplexing (or combining) many different streams into a single one. This is a complicated subject because it enables protocols to run concurrently over the same wire, and all sorts of notions regarding fairness, flow control, head-of-line blocking, etc. start affecting the protocols. In practice, stream multiplexing is well understood and there are many stream multiplexing protocols. To name a few:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;HTTP/2&lt;/li&gt;
&lt;li&gt;SPDY&lt;/li&gt;
&lt;li&gt;QUIC&lt;/li&gt;
&lt;li&gt;SSH&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IPFS nodes are free to support whatever stream multiplexors they wish, on top of the default one. The default one is there to enable even the simplest of nodes to speak multiple protocols at once. The default multiplexor will be HTTP/2 (or maybe QUIC?), but implementations for it are sparse, so we are beginning with SPDY. We simply select which protocol to use with a multistream header.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/ipfs/QmdRKVhvzyATs3L6dosSb6w8hKuqfZK2SyPVqcYJ5VLYa2/multistream-select/0.3.0
/ipfs/Qmb4d8ZLuqnnVptqTxwqt3aFqgPYruAbfeksvRV1Ds8Gri/spdy/3
&amp;lt;spdy-header-opening-a-stream-0&amp;gt;
/ipfs/QmVXZiejj3sXEmxuQxF2RjmFbEiE9w7T82xDn3uYNuhbFb/ipfs-dht/0.2.3
&amp;lt;dht-message&amp;gt;
&amp;lt;dht-message&amp;gt;
&amp;lt;spdy-header-opening-a-stream-1&amp;gt;
/ipfs/QmVXZiejj3sXEmxuQxF2RjmFbEiE9w7T82xDn3uYNuhbFb/ipfs-bitswap/0.3.0
&amp;lt;bitswap-message&amp;gt;
&amp;lt;bitswap-message&amp;gt;
&amp;lt;spdy-header-selecting-stream-0&amp;gt;
&amp;lt;dht-message&amp;gt;
&amp;lt;dht-message&amp;gt;
&amp;lt;dht-message&amp;gt;
&amp;lt;dht-message&amp;gt;
&amp;lt;spdy-header-selecting-stream-1&amp;gt;
&amp;lt;bitswap-message&amp;gt;
&amp;lt;bitswap-message&amp;gt;
&amp;lt;bitswap-message&amp;gt;
&amp;lt;bitswap-message&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;7-5-5-portable-encodings&#34;&gt;7.5.5 Portable Encodings&lt;/h3&gt;

&lt;p&gt;In order to be ubiquitous, we &lt;em&gt;must&lt;/em&gt; use hyper-portable format encodings, those that are easy to use in various other platforms. Ideally these encodings are well-tested in the wild, and widely used. There may be cases where multiple encodings have to be supported (and hence we may need a &lt;a href=&#34;https://github.com/jbenet/multicodec&#34;&gt;multicodec&lt;/a&gt; self-describing encoding), but this has so far not been needed.
For now, we use &lt;a href=&#34;https://github.com/google/protobuf&#34;&gt;protobuf&lt;/a&gt; for all protocol messages exclusively, but other good candidates are &lt;a href=&#34;https://capnproto.org/&#34;&gt;capnp&lt;/a&gt;, &lt;a href=&#34;http://bsonspec.org/&#34;&gt;bson&lt;/a&gt;, and &lt;a href=&#34;http://ubjson.org/&#34;&gt;ubjson&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;7-5-6-secure-communications&#34;&gt;7.5.6 Secure Communications&lt;/h3&gt;

&lt;p&gt;The wire protocol is &amp;ndash; of course &amp;ndash; wrapped with encryption. We use cyphersuites similar to TLS. This is explained further in the &lt;a href=&#34;./#encryption&#34;&gt;network spec&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;7-5-7-protocol-multicodecs&#34;&gt;7.5.7 Protocol Multicodecs&lt;/h3&gt;

&lt;p&gt;Here, we present a table with the multicodecs defined for each IPFS protocol that has a wire componenent. This list may change over time and currently exists as a guide for implementation.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;protocol&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;multicodec&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;secio&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/secio/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;TLS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/tls/1.3.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;plaintext&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/plaintext/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;spdy&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/spdy/3.1.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;yamux&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/yamux/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;multiplex&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/multiplex/6.7.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;identify&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/ipfs/id/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ping&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/ipfs/ping/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;relay&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/ipfs/relay/line/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;diagnostics&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/ipfs/diag/net/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Kademlia DHT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/ipfs/kad/1.0.0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;bitswap&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;/ipfs/bitswap/1.0.0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>8 Implementations</title>
      <link>/specs/8-implementations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/8-implementations/</guid>
      <description>

&lt;p&gt;A &lt;code&gt;libp2p&lt;/code&gt; implementation should (recommended) follow a certain level of granulatiry when implementing different modules and functionalities, so that common interfaces are easy to expose, test and check for interoperability with other implementations.&lt;/p&gt;

&lt;p&gt;This is the list of current modules available for &lt;code&gt;libp2p&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;libp2p (entry point)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Swarm&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;libp2p-swarm&lt;/li&gt;
&lt;li&gt;libp2p-identify&lt;/li&gt;
&lt;li&gt;libp2p-ping&lt;/li&gt;
&lt;li&gt;Transports

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-transport&#34;&gt;interface-transport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-connection&#34;&gt;interface-connection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libp2p-tcp&lt;/li&gt;
&lt;li&gt;libp2p-udp&lt;/li&gt;
&lt;li&gt;libp2p-udt&lt;/li&gt;
&lt;li&gt;libp2p-utp&lt;/li&gt;
&lt;li&gt;libp2p-webrtc&lt;/li&gt;
&lt;li&gt;libp2p-cjdns&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Stream Muxing

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-stream-muxer&#34;&gt;interface-stream-muxer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libp2p-spdy&lt;/li&gt;
&lt;li&gt;libp2p-multiplex&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Crypto Channel

&lt;ul&gt;
&lt;li&gt;libp2p-tls&lt;/li&gt;
&lt;li&gt;libp2p-secio&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Peer Routing&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;libp2p-kad-routing&lt;/li&gt;
&lt;li&gt;libp2p-mDNS-routing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Discovery&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;libp2p-mdns-discovery&lt;/li&gt;
&lt;li&gt;libp2p-random-walk&lt;/li&gt;
&lt;li&gt;libp2p-railing&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Distributed Record Store&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;libp2p-record&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/diasdavid/interface-record-store&#34;&gt;interface-record-store&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;libp2p-distributed-record-store&lt;/li&gt;
&lt;li&gt;libp2p-kad-record-store&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Generic&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;PeerInfo&lt;/li&gt;
&lt;li&gt;PeerId&lt;/li&gt;
&lt;li&gt;multihash&lt;/li&gt;
&lt;li&gt;multiaddr&lt;/li&gt;
&lt;li&gt;multistream&lt;/li&gt;
&lt;li&gt;multicodec&lt;/li&gt;
&lt;li&gt;ipld&lt;/li&gt;
&lt;li&gt;repo&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Current known implementations (or WIP) are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;JavaScript - &lt;a href=&#34;https://github.com/diasdavid/js-libp2p&#34;&gt;https://github.com/diasdavid/js-libp2p&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Go - &lt;a href=&#34;https://github.com/ipfs/go-libp2p&#34;&gt;https://github.com/ipfs/go-libp2p&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Python - &lt;a href=&#34;https://github.com/candeira/py-ipfs/blob/readme-roadmap/README.md&#34;&gt;https://github.com/candeira/py-ipfs/blob/readme-roadmap/README.md&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Rust - &lt;a href=&#34;https://github.com/diasdavid/rust-libp2p&#34;&gt;https://github.com/diasdavid/rust-libp2p&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-1-swarm&#34;&gt;8.1 Swarm&lt;/h2&gt;

&lt;h3 id=&#34;8-1-1-swarm-dialer&#34;&gt;8.1.1 Swarm Dialer&lt;/h3&gt;

&lt;p&gt;The swarm dialer manages making a successful connection to a target peer, given a stream of addresses as inputs, and making sure to respect any and all rate limits imposed. To this end, we have designed the following logic for dialing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DialPeer(peerID) {
	if PeerIsBeingDialed(peerID) {
		waitForDialToComplete(peerID)
		return BestConnToPeer(peerID)
	}
	
	StartDial(peerID)

	waitForDialToComplete(peerID)
	return BestConnToPeer(peerID)
}

	
StartDial(peerID) {
	addrs = getAddressStream(peerID)

	addrs.onNewAddr(function(addr) {
		if rateLimitCanDial(peerID, addr) {
			doDialAsync(peerID, addr)
		} else {
			rateLimitScheduleDial(peerID, addr)
		}
	})
}

// doDialAsync starts dialing to a specific address without blocking.
// when the dial returns, it releases rate limit tokens, and if it
// succeeded, will finalize the dial process.
doDialAsync(peerID, addr) {
	go transportDial(addr, function(conn, err) {
		rateLimitReleaseTokens(peerID, addr)

		if err != null {
			// handle error
		}

		dialSuccess(conn)
	})
}

// rateLimitReleaseTokens checks for any tokens the given dial
// took, and then for each of them, checks if any other dial is waiting
// for any of those tokens. If waiting dials are found, those dials are started
// immediately. Otherwise, the tokens are released to their pools.
rateLimitReleaseTokens(peerID, addr) {
	tokens = tokensForDial(peerID, addr)

	for token in tokens {
		dial = dialWaitingForToken(token)
		if dial != null {
			doDialAsync(dial.peer, dial.addr)
		} else {
			token.release()
		}
	}
	
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>9 References</title>
      <link>/specs/9-references/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/specs/9-references/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs): &lt;a href=&#34;https://tools.ietf.org/html/rfc5128&#34;&gt;https://tools.ietf.org/html/rfc5128&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>